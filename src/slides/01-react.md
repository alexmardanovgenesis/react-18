
![](https://massivepixel.io/app/uploads/2022/02/react-latest-version-hero-header.png)

18.0.0 (March 29, 2022)

---

## Новые хуки

- useId
- startTransition и useTransition
- useDeferredValue
- useSyncExternalStore
- useInsertionEffect

---

## useId

Это новый хук для создания уникальных идентификаторов как на клиенте, так и на сервере, избегая при этом hydration несоответствий. Это в первую очередь полезно для библиотек компонентов, интегрирующихся с API, для которых требуются уникальные идентификаторы. Это решает проблему, которая уже существует в React 17 и более ранних версиях, но еще более важна в React 18 из-за того, что новый рендерер сервера доставляет HTML не по порядку.

```
const id = useId()

id = ':Rm:'
```

---

## startTransition и useTransition

Позволяют помечать некоторые обновления состояния как несрочные. Другие обновления состояния по умолчанию считаются срочными. React позволит срочным обновлениям состояния (например, обновлению ввода текста) прерывать несрочные обновления состояния (например, отображение списка результатов поиска).

```
const [isPending, startTransition] = useTransition()

startTransition(() => {
  setSearchResult(list)
})
```

---

## useDeferredValue

Позволяет отложить повторный рендеринг несрочной части дерева. Он похож на debouncing, но имеет несколько преимуществ по сравнению с ним. Фиксированной задержки по времени нет, поэтому React попытается выполнить отложенный рендеринг сразу после того, как первый рендер отобразится на экране. Отложенный рендеринг может быть прерван и не будет блокировать ввод данных пользователем.

```
const [text, setText] = useState("hello")

const deferredText = useDeferredValue(text)

<input value={text} onChange={(e) => setText(e.target.value)}>

<BlockTitle>{text}</BlockTitle>
```

---

## useSyncExternalStore

Это новый хук, который позволяет внешним хранилищам поддерживать параллельное чтение, заставляя обновления в хранилище быть синхронными. Он устраняет необходимость в useEffect при реализации подписок на внешние источники данных и рекомендуется для любой библиотеки, которая интегрируется со сторонним состоянием по отношению к React.

---

## useInsertionEffect

Это новый хук, который позволяет библиотекам CSS-in-JS решать проблемы с производительностью при внедрении стилей во время рендеринга. Если вы не планируете создавать библиотеку CSS-in-JS, мы не ожидаем, что вы когда-либо будете это использовать. Этот хук запустится после изменения DOM, но до того, как эффекты лейаута узнают об этом. Это решает проблему, которая уже существует в React 17 и более ранних версиях, но еще более важна в React 18, поскольку React уступает браузеру во время одновременного рендеринга, давая ему возможность пересчитать лейаут.

---

## Критические изменения

---

## Автоматическая пакетная обработка (Automatic Batching)

В этом релизе представлено улучшение производительности, которое меняет способ пакетной обработки обновлений React для автоматического выполнения большей пакетной обработки. В редких случаях, когда вам нужно отказаться, оберните обновление состояния в flushSync.

---

React 17 выполнит рендеринг дважды, один для каждого обновления состояния (т.е. пакетирование отсутствует).

```js
setTimeout(() => {
  setCount(c => c + 1)
  setFlag(f => !f)
}, 1000)
```

В React 18 обновления внутри setTimeout, промисах, нативных обработчиках событий или любые другие события - пакетируются. React выполнит только один перерендер в конце (это и есть пакетирование!)

---

## Более строгий строгий режим

В будущем React предоставит функцию, позволяющую компонентам сохранять состояние между анмаунтами. Чтобы подготовиться к этому, React 18 вводит новую проверку только для разработки в строгом режиме. React автоматически анмаунтит и маунтит каждый компонент всякий раз, когда компонент создаётся в первый раз, восстанавливая предыдущее состояние при втором маунте. Если это сломает ваше приложение, рассмотрите возможность удаления строгого режима, пока вы не сможете исправить компоненты, чтобы они были устойчивы к повторному маунту с существующим состоянием.

---

## Согласованное время useEffect

React теперь всегда синхронно сбрасывает функции эффектов, если обновление было запущено во время дискретного события пользовательского ввода, такого как щелчок или событие нажатия клавиши. Раньше поведение не всегда было предсказуемым или последовательным.

---

## Более строгие ошибки гидратации

Несоответствия гидратации из-за отсутствующего или дополнительного текстового содержимого теперь обрабатываются как ошибки, а не как предупреждения. React больше не будет пытаться «исправлять» отдельные узлы, вставляя или удаляя узел на клиенте в попытке сопоставить разметку сервера, и вернется к рендерингу клиента до ближайшей границы Suspense в дереве. Это гарантирует согласованность гидратированного дерева и позволяет избежать потенциальных дыр в конфиденциальности и безопасности, которые могут быть вызваны несоответствием гидратации.

---

## Эффекты лейаута с Suspense

Когда дерево повторно приостанавливается и возвращается к fallback варианту, React теперь очищает эффекты лейаута, а затем воссоздает их, когда содержимое внутри границы снова отображается. Это устраняет проблему, из-за которой библиотеки компонентов не могли правильно измерить лейаут при использовании с Suspense.

---

## Новые требования к среде JS

React теперь зависит от современных функций браузеров, включая Promise, Symbol и Object.assign. Если вы поддерживаете более старые браузеры и устройства, такие как Internet Explorer, которые изначально не предоставляют современные функции браузера или имеют несовместимые реализации, рассмотрите возможность включения глобального полифилла в приложение.

---

## Заметные изменения

---

**Компоненты теперь могут отображать undefined:** React больше не выбрасывает ошибку, если вы возвращаете undefined из компонента.

---

**В тестах предупреждения об act теперь являются необязательными:** если вы выполняете сквозные тесты, предупреждения об act не нужны. Мы ввели механизм отказа, поэтому вы можете включить их только для модульных тестов, где они полезны и выгодны.

---

**Нет предупреждений о setState для несозданных компонентов:** раньше React предупреждал об утечках памяти, когда вы вызывали setState для несозданного компонента. Это предупреждение было добавлено для подписок, но люди в основном сталкиваются с ним в сценариях, где состояние настроек в порядке, а обходные пути ухудшают код. Мы удалили это предупреждение.

---

**Убрали скрытие журналов консоли:** при использовании строгого режима React дважды визуализирует каждый компонент, чтобы помочь вам найти неожиданные побочные эффекты. В React 17 мы скрыли журналы консоли для одного из двух рендеров, чтобы облегчить чтение журналов. В ответ на отзывы сообщества о том, что это сбивает с толку, мы удалили скрытие. Вместо этого, если у вас установлен React DevTools, рендеры второго журнала будут отображаться серым цветом, и будет возможность (по умолчанию отключена) полностью их скрыть.

---

**Улучшенное использование памяти:** React теперь очищает больше внутренних полей при анмаунте, что делает влияние незафиксированных утечек памяти, которые могут существовать в коде вашего приложения, менее серьезным.

---

## 1) Клиентский рендеринг

![](/screen-1.png)

---

## 2) Серверный рендеринг

![](/screen-2.png)

---

## React Server Components — что это?

Это компоненты которые исполняются на сервере <img src="https://i.kym-cdn.com/entries/icons/facebook/000/000/091/TrollFace.jpg" alt="" width="100" />

---

## Клиентские компоненты

Это те компоненты которые мы пишем сейчас, используя состояние и эффекты, они позволяют взаимодействовать с пользователем и исполняются в браузере. До этого момента у нас существовали только клиентские компоненты. Теперь клиентские компоненты имеют постфикс в названии .client.js

---

## Серверные компоненты

Это те компоненты которые исполняются на сервере, они не могут использовать состояние и эффекты (в них запрещено использование useState и любых других “клиентских” хуков). Они могут быть перезапрошены по ходу исполнения приложения. Имеют доступ ко всей инфраструктуре сервера. Такие компоненты имеют постфикс в названии .server.js. Также в качестве параметров не может передавать функции, только данные.

---

## Гибридные компоненты

Эти компоненты могут исполняться как на сервере так и на клиенте. У них самые сильные ограничения. Они не могут использовать клиентские хуки и серверную инфраструктуру. Фактически могут только содержать JSX разметку.

---

### React рендерит дерево из компонентов разного типа

<img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/8b5/a2b/ee9/8b5a2bee99177b42347300c34a74c24d.png" width="500" />

---

## Новые функциональные возможности Suspense

Suspense позволяет вам декларативно отображать состояние загрузки для части дерева компонентов, если она еще не готова к отображению:

```
<Suspense fallback={<Spinner />}>
  <Comments />
</Suspense>
```

---

## Пример

![](/screen-3.png)

---

# Плюсы RSC

### Zero-Bundle-Size Components
### Полный доступ к Backend
### Автоматический Code Splitting
### Отсутствие client-server водопадов

---

### Zero-Bundle-Size Components

Сервер может «дешевле» использовать «тяжелые» модули — например, npm-пакет для рендеринга разметки в html — потому что серверу не нужно загружать зависимости каждый раз, когда они используются, в отличие от браузера, который должен загружать весь используемый код.

---

### Полный доступ к Backend

Сервер ближе к данным — будь то базы данных, GraphQL-эндпоинты или файловая система. Сервер может напрямую забрать нужные вам данные, не обращаясь куда-то по апишке, и обычно он «ближе» к источникам данных, поэтому может получать данные быстрее.

---

### Автоматический Code Splitting

```js
import React from 'react';

import OldPhotoRenderer from './OldPhotoRenderer.client.js';
import NewPhotoRenderer from './NewPhotoRenderer.client.js';

function Photo(props) {
  if (FeatureFlags.useNewPhotoRenderer) {
    return <NewPhotoRenderer {...props} />;
  } else {
    return <OldPhotoRenderer {...props} />;
  }
}
```

---

# Go coding... <img src="https://c.tenor.com/nEF800vPQh8AAAAC/naruto-run-peepo.gif" width="100" />
